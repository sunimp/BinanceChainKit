//
//  DexProtobuf.swift
//
//  Created by Sun on 2019/7/29.
//

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dex.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// MARK: - _GeneratedWithProtocGenSwiftVersion

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that your are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 { }
    typealias Version = _2
}

// MARK: - StdTx

/// please note the field name is the JSON name.
struct StdTx {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    uint64 SIZE-OF-ENCODED // varint encoded length of the structure after encoding
    ///    0xF0625DEE   // hardcoded, object type prefix in 4 bytes
    var msgs: [Data] = []

    /// array of size 1, containing the standard signature structure of the transaction sender
    var signatures: [Data] = []

    /// a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and
    /// other transactions with non-empty `Memo` would be rejected.
    var memo = String()

    /// an identifier for tools triggerring this transaction, set to zero if unwilling to disclose.
    var source: Int64 = 0

    /// byte array, reserved for future use
    var data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - StdSignature

struct StdSignature {
    // MARK: Nested Types

    /// please note there is no type prefix for StdSignature
    struct PubKey {
        // MARK: Properties

        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        // MARK: Lifecycle

        init() { }
    }

    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// public key bytes of the signer address
    var pubKey = Data()

    /// signature bytes, please check chain access section for signature generation
    var signature = Data()

    /// another identifier of signer, which can be read from chain by account REST API or RPC
    var accountNumber: Int64 = 0

    /// sequence number for the next transaction of the client, which can be read fro chain by account REST API or RPC.
    /// please check chain acces section for details.
    var sequence: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - NewOrder

/// please note the field name is the JSON name.
struct NewOrder {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    0xCE6DC043 // hardcoded, object type prefix in 4 bytes
    var sender = Data()

    /// order id, optional
    var id = String()

    /// symbol for trading pair in full name of the tokens
    var symbol = String()

    /// only accept 2 for now, meaning limit order
    var ordertype: Int64 = 0

    /// 1 for buy and 2 fory sell
    var side: Int64 = 0

    /// price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer
    var price: Int64 = 0

    /// quantity of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer
    var quantity: Int64 = 0

    /// 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC)
    var timeinforce: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - CancelOrder

/// please note the field name is the JSON name.
struct CancelOrder {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    0x166E681B   // hardcoded, object type prefix in 4 bytes
    var sender = Data()

    /// symbol for trading pair in full name of the tokens
    var symbol = String()

    /// order id of the one to cancel
    var refid = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - TokenFreeze

/// please note the field name is the JSON name.
struct TokenFreeze {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    0xE774B32D   // hardcoded, object type prefix in 4 bytes
    var from = Data()

    /// token symbol, in full name with "-" suffix
    var symbol = String()

    /// amount of token to freeze
    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - TokenUnfreeze

/// please note the field name is the JSON name.
struct TokenUnfreeze {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    0x6515FF0D   // hardcoded, object type prefix in 4 bytes
    var from = Data()

    /// token symbol, in full name with "-" suffix
    var symbol = String()

    /// amount of token to freeze
    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - Send

/// please note the field name is the JSON name.
struct Send {
    // MARK: Nested Types

    ///    0x2A2C87FA   // hardcoded, object type prefix in 4 bytes
    struct Token {
        // MARK: Properties

        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var denom = String()

        var amount: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        // MARK: Lifecycle

        init() { }
    }

    struct Input {
        // MARK: Properties

        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var address = Data()

        var coins: [Send.Token] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        // MARK: Lifecycle

        init() { }
    }

    struct Output {
        // MARK: Properties

        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var address = Data()

        var coins: [Send.Token] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        // MARK: Lifecycle

        init() { }
    }

    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inputs: [Send.Input] = []

    var outputs: [Send.Output] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - Vote

/// please note the field name is the JSON name.
struct Vote {
    // MARK: Properties

    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///    0xA1CADD36	    // hardcoded, object type prefix in 4 bytes
    var proposalID: Int64 = 0

    /// address of the voter
    var voter = Data()

    /// option from OptionSet chosen by the voter,
    var option: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - TransferOut

struct TransferOut {
    // MARK: Properties

    var from = Data()
    var to = Data()
    var amount = Send.Token()
    var expireTime: Int64 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    // MARK: Lifecycle

    init() { }
}

// MARK: - StdTx + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension StdTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "StdTx"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "msgs"),
        2: .same(proto: "signatures"),
        3: .same(proto: "memo"),
        4: .same(proto: "source"),
        5: .same(proto: "data"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedBytesField(value: &msgs)
            case 2: try decoder.decodeRepeatedBytesField(value: &signatures)
            case 3: try decoder.decodeSingularStringField(value: &memo)
            case 4: try decoder.decodeSingularInt64Field(value: &source)
            case 5: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !msgs.isEmpty {
            try visitor.visitRepeatedBytesField(value: msgs, fieldNumber: 1)
        }
        if !signatures.isEmpty {
            try visitor.visitRepeatedBytesField(value: signatures, fieldNumber: 2)
        }
        if !memo.isEmpty {
            try visitor.visitSingularStringField(value: memo, fieldNumber: 3)
        }
        if source != 0 {
            try visitor.visitSingularInt64Field(value: source, fieldNumber: 4)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: StdTx, rhs: StdTx) -> Bool {
        if lhs.msgs != rhs.msgs {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        if lhs.memo != rhs.memo {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - StdSignature + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension StdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "StdSignature"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "pub_key"),
        2: .same(proto: "signature"),
        3: .standard(proto: "account_number"),
        4: .same(proto: "sequence"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &pubKey)
            case 2: try decoder.decodeSingularBytesField(value: &signature)
            case 3: try decoder.decodeSingularInt64Field(value: &accountNumber)
            case 4: try decoder.decodeSingularInt64Field(value: &sequence)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !pubKey.isEmpty {
            try visitor.visitSingularBytesField(value: pubKey, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
        }
        if accountNumber != 0 {
            try visitor.visitSingularInt64Field(value: accountNumber, fieldNumber: 3)
        }
        if sequence != 0 {
            try visitor.visitSingularInt64Field(value: sequence, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: StdSignature, rhs: StdSignature) -> Bool {
        if lhs.pubKey != rhs.pubKey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.accountNumber != rhs.accountNumber {
            return false
        }
        if lhs.sequence != rhs.sequence {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - StdSignature.PubKey + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension StdSignature.PubKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = StdSignature.protoMessageName + ".PubKey"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() { }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: StdSignature.PubKey, rhs: StdSignature.PubKey) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - NewOrder + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension NewOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "NewOrder"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sender"),
        2: .same(proto: "id"),
        3: .same(proto: "symbol"),
        4: .same(proto: "ordertype"),
        5: .same(proto: "side"),
        6: .same(proto: "price"),
        7: .same(proto: "quantity"),
        8: .same(proto: "timeinforce"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &sender)
            case 2: try decoder.decodeSingularStringField(value: &id)
            case 3: try decoder.decodeSingularStringField(value: &symbol)
            case 4: try decoder.decodeSingularInt64Field(value: &ordertype)
            case 5: try decoder.decodeSingularInt64Field(value: &side)
            case 6: try decoder.decodeSingularInt64Field(value: &price)
            case 7: try decoder.decodeSingularInt64Field(value: &quantity)
            case 8: try decoder.decodeSingularInt64Field(value: &timeinforce)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !sender.isEmpty {
            try visitor.visitSingularBytesField(value: sender, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        if !symbol.isEmpty {
            try visitor.visitSingularStringField(value: symbol, fieldNumber: 3)
        }
        if ordertype != 0 {
            try visitor.visitSingularInt64Field(value: ordertype, fieldNumber: 4)
        }
        if side != 0 {
            try visitor.visitSingularInt64Field(value: side, fieldNumber: 5)
        }
        if price != 0 {
            try visitor.visitSingularInt64Field(value: price, fieldNumber: 6)
        }
        if quantity != 0 {
            try visitor.visitSingularInt64Field(value: quantity, fieldNumber: 7)
        }
        if timeinforce != 0 {
            try visitor.visitSingularInt64Field(value: timeinforce, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: NewOrder, rhs: NewOrder) -> Bool {
        if lhs.sender != rhs.sender {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.ordertype != rhs.ordertype {
            return false
        }
        if lhs.side != rhs.side {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        if lhs.timeinforce != rhs.timeinforce {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - CancelOrder + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension CancelOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "CancelOrder"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sender"),
        2: .same(proto: "symbol"),
        3: .same(proto: "refid"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &sender)
            case 2: try decoder.decodeSingularStringField(value: &symbol)
            case 3: try decoder.decodeSingularStringField(value: &refid)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !sender.isEmpty {
            try visitor.visitSingularBytesField(value: sender, fieldNumber: 1)
        }
        if !symbol.isEmpty {
            try visitor.visitSingularStringField(value: symbol, fieldNumber: 2)
        }
        if !refid.isEmpty {
            try visitor.visitSingularStringField(value: refid, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CancelOrder, rhs: CancelOrder) -> Bool {
        if lhs.sender != rhs.sender {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.refid != rhs.refid {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - TokenFreeze + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension TokenFreeze: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "TokenFreeze"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "symbol"),
        3: .same(proto: "amount"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &from)
            case 2: try decoder.decodeSingularStringField(value: &symbol)
            case 3: try decoder.decodeSingularInt64Field(value: &amount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularBytesField(value: from, fieldNumber: 1)
        }
        if !symbol.isEmpty {
            try visitor.visitSingularStringField(value: symbol, fieldNumber: 2)
        }
        if amount != 0 {
            try visitor.visitSingularInt64Field(value: amount, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: TokenFreeze, rhs: TokenFreeze) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - TokenUnfreeze + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension TokenUnfreeze: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "TokenUnfreeze"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "symbol"),
        3: .same(proto: "amount"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &from)
            case 2: try decoder.decodeSingularStringField(value: &symbol)
            case 3: try decoder.decodeSingularInt64Field(value: &amount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularBytesField(value: from, fieldNumber: 1)
        }
        if !symbol.isEmpty {
            try visitor.visitSingularStringField(value: symbol, fieldNumber: 2)
        }
        if amount != 0 {
            try visitor.visitSingularInt64Field(value: amount, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: TokenUnfreeze, rhs: TokenUnfreeze) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - Send + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Send: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "Send"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "inputs"),
        2: .same(proto: "outputs"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &inputs)
            case 2: try decoder.decodeRepeatedMessageField(value: &outputs)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !inputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: inputs, fieldNumber: 1)
        }
        if !outputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: outputs, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Send, rhs: Send) -> Bool {
        if lhs.inputs != rhs.inputs {
            return false
        }
        if lhs.outputs != rhs.outputs {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - Send.Token + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Send.Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Send.protoMessageName + ".Token"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "denom"),
        2: .same(proto: "amount"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &denom)
            case 2: try decoder.decodeSingularInt64Field(value: &amount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !denom.isEmpty {
            try visitor.visitSingularStringField(value: denom, fieldNumber: 1)
        }
        if amount != 0 {
            try visitor.visitSingularInt64Field(value: amount, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Send.Token, rhs: Send.Token) -> Bool {
        if lhs.denom != rhs.denom {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - Send.Input + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Send.Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Send.protoMessageName + ".Input"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "coins"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeRepeatedMessageField(value: &coins)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if !coins.isEmpty {
            try visitor.visitRepeatedMessageField(value: coins, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Send.Input, rhs: Send.Input) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.coins != rhs.coins {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - Send.Output + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Send.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Send.protoMessageName + ".Output"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "coins"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeRepeatedMessageField(value: &coins)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if !coins.isEmpty {
            try visitor.visitRepeatedMessageField(value: coins, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Send.Output, rhs: Send.Output) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.coins != rhs.coins {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - Vote + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "Vote"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "proposal_id"),
        2: .same(proto: "voter"),
        3: .same(proto: "option"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &proposalID)
            case 2: try decoder.decodeSingularBytesField(value: &voter)
            case 3: try decoder.decodeSingularInt64Field(value: &option)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if proposalID != 0 {
            try visitor.visitSingularInt64Field(value: proposalID, fieldNumber: 1)
        }
        if !voter.isEmpty {
            try visitor.visitSingularBytesField(value: voter, fieldNumber: 2)
        }
        if option != 0 {
            try visitor.visitSingularInt64Field(value: option, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Vote, rhs: Vote) -> Bool {
        if lhs.proposalID != rhs.proposalID {
            return false
        }
        if lhs.voter != rhs.voter {
            return false
        }
        if lhs.option != rhs.option {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}

// MARK: - TransferOut + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension TransferOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName = "TransferOut"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "to"),
        3: .same(proto: "amount"),
        4: .standard(proto: "expire_time"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &from)

            case 2: try decoder.decodeSingularBytesField(value: &to)

            case 3:
                var amount: Send.Token?
                try decoder.decodeSingularMessageField(value: &amount)
                amount.flatMap { self.amount = $0 }

            case 4: try decoder.decodeSingularInt64Field(value: &expireTime)

            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularBytesField(value: from, fieldNumber: 1)
        }
        if !to.isEmpty {
            try visitor.visitSingularBytesField(value: to, fieldNumber: 2)
        }
        try visitor.visitSingularMessageField(value: amount, fieldNumber: 3)
        if expireTime != 0 {
            try visitor.visitSingularInt64Field(value: expireTime, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: TransferOut, rhs: TransferOut) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.to != rhs.to {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.expireTime != rhs.expireTime {
            return false
        }
        if lhs.unknownFields != rhs.unknownFields {
            return false
        }
        return true
    }
}
